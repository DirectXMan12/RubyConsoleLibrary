h1. RubyConsoleLibrary

* An ncurses-/curses-like library for building console applications
** RubyConsoleLibrary is different from other ruby console libraries in that it is written wholly in ruby, with out any native code required (see below)

h3. [-note: not yet ruby 1.9 compatible-] [+Now working with Ruby 1.9!+]

h2. - Requirements/Installation -

* if you are on Windows, and are using the default command prompt (or powershell, etc), you must install win32console for this library to work correctly - it adds standard ANSI support to the windows console
* [-if you are on another platform, comment out the "require 'win32console'" line, however, do note that this has not been tested yet on linux, etc, however,-] [+RubyConsoleLibrary will automatically detect a windows installation, as+] the aim is to eventually ensure that it is automatically cross-platform (which ncurses isn't really...)
* [-finally, you may wish to comment out "require 'ruby-debug'-]

h2. - Usage -

require 'console-main.rb'
include RubyConsoleLibrary

h2. - Example -

see the file "tester.rb" in the root directory, as well as below

bc.. require 'console-main.rb'
include RubyConsoleLibrary

a = ConsoleApp.new                      # initialize a new application
w = a.wins[0]                           # acquire the "handle" for the window automatically created above
                                        #    (note: syntax for the "box" command may change shortly)
w.box 10,10, :background_blue           # create a 10 x 10 box, with a border of white on blue

w.refresh                               # refresh the screen to display the window at the console
                                        #    (note: this will probably soon be a call to the application, not the window)

t = TextBoxControl.new(w, 5, [10, 4])   # create a new text box with the window "w" as the parent, that is 5 characters wide, at the position (10, 4)
                                        #    (note: this will soon be called in the manner of w.text_box...)
w.new_control t                         # add the control to "w"
t.enabled = true                        # and enable it

q = TextBoxControl.new(w, 7, [10, 12])  # same as above
w.new_control q
q.enabled = true

w.refresh 

inrouter = InputRouter.new(w)           # create an input router, which handles application input for the window "w"

inrouter.bindings do                    # define the input "routes" with a DSL
	bind_key(:up_arrow) do          # make the up arrow...
		focus_prev              # ...shift focus to the previous control in "w"'s control stack
	end
	bind_key(:down_arrow) do
		focus_next
	end
	bind_key(:enter) do             # make enter signify that all input (via capture_all_input) send all input to the currently focused control (implied in feed_through) until the escape key is pressed (note: exceptions can be specified with :except => [:a,:b,:up_arrow])
		capture_all_input :until => :escape do
			feed_through 
		end
	end
end

instr = ""
while (instr != "x")                   # exit the app on pressing the "x" key
	w.refresh                      # refresh the window
	instr = Utils.getch(false)     # get a single character without constraining the input to letter characters
	inrouter.handle_input(instr)   # handle the resulting input

end
a.cleanup                              # cleanup the console before exiting (deals with character sets, cancels ANSI effects, etc)
